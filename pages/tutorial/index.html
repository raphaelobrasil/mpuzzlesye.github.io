<div title>Tutorial</div>
<div section-description> 
    Há duas formas básicas para o uso do MPuzzleSyE. A primeira chamo de <span mark>Step-To-Step</span>, a segunda de <span mark>End-To-End</span>. <br/>
    É importante frisar que o fluxo principal é assíncrono, portanto, durante a execução dos métodos, desenvolva sempre com a possibilidade de ter que lidar com Promises. 
</div>
<div class="tableContent" style="width: 95%;">
    <div class="cardContent">
        <div descript-col style="max-width: 100%;">
            <span>
                <strong>Observação:</strong> 
                Todas as funções do MPuzzleSyE possui carga de processamento menor que 0.02s em condições normais. Inclusive, a própria função do End-To-End cumpre esse requisito.
                Porém, o layout também afetará diretamente no desempenho do jogo, sugiro tomar cuidado com o uso de dados pesados em conjunto com o fluxo, quanto mais limpo for, melhor a performance. <br/><br/>
                A renderização do tabuleiro e todo o layout ficará seu a critério, aqui irei apenas instruir como utilizar o fluxo lógico. 
            </span>
        </div>
    </div>
</div>
<div title-sub>
    Método <span mark>Step-To-Step</span> (STS)
</div>
<div section-description>
    O fluxo <span mark>STS</span> é sem dúvida o fluxo mais flexível e leve. Com ele você pode ir executando cada etapa do processo
    enquanto reage visualmente, a probabilidade de criar um fluxo onde o jogador sinta "a espera" é menor, em troca, há mais custo de desenvolvimento. <br/><br/>
    Primeiro, é necessário importar as funções que serão utilizadas e configurar o tipo de conteúdo que será usado. <br/>
    O conteúdo é a informação preenchida no tabuleiro, em default é configurado com 5 cores: 
    <span mark>dark</span>, 
    <span mark>light</span>, 
    <span mark>red</span>, 
    <span mark>blue</span> e 
    <span mark>green</span>.<br/>
    E aqui também definimos as categorias de efeitos, que são "conteúdo especial" que causam efeitos diversificados, por default temos as categorias <span mark>pattern_four</span> e <span mark>pattern_five</span> que são conquistados ao realizar matchs com 4 e 5 conteúdos em uma combinação, respectivamente.<br/>
    E há o conteúdo <span mark>void</span> que define quando uma célula do tabuleiro está vazia.  <br/><br/>
    Os conteúdos configurados no <span mark>stoneConfig</span> recebem ids enumerados a partir do 1. O id 0 é reservado para o espaço vázio, <span mark>void</span>.  
</div>
<div title-sub>
    Imports
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`import { stoneConfig, gameStart, isMatch, clearMatchs, category, activeEffectsInMatchs, sequenceHistory, clearTableMatchAndEffects, organizeStructure, insertNewStones } from 'mpuzzlesye'`, 'clip-1')"
        svg clip="no"
        id="clip-1"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>import { stoneConfig, gameStart, isMatch, clearMatchs, category, activeEffectsInMatchs, sequenceHistory, clearTableMatchAndEffects, organizeStructure, insertNewStones } from 'mpuzzlesye'</div>
        </div>
    </div>
</div>
<div title-sub>
    Conteúdo default
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect('const config = stoneConfig({})', 'clip-2')"
        svg clip="no"
        id="clip-2"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const config = stoneConfig({})</div>
        </div>
    </div>
</div>
<div title-sub>
    Conteúdo customizado
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const config = stoneConfig({stones: ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE'], categorys: ['A', 'B']})`, 'clip-3')"
        svg clip="no"
        id="clip-3"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const config = stoneConfig({stones: ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE'], categorys: ['A', 'B']})</div>
        </div>
    </div>
</div>
<div section-description>
    Configurado o conteúdo, que para ficar mais fácil o entendimento, irei chamar de <span mark>pedras</span>. Precisamos iniciar o tabuleiro preenchido com as pedras configuradas. <br/>
    Há uma regra aqui, precisamos criar um <span mark>tabuleiro limpo</span>, esse "conceito" é quando o tabuleiro está com as pedras bem distribuídas entre as células, sem nenhum match. <br/>
    Aqui apresento o recurso de <span mark>fHelps</span>. São métodos de nível maior que invocam métodos unitários simples e realizam um conjunto de ações mais complexas, facilitando a utilização dos métodos unitários. <br/>
    Iremos criar um tabuleiro 5x7 (5 linhas e 7 colunas), sem matchs e preenchidos com as pedras definidas.
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const table = await gameStart({ rowCount: 5, columnCount: 7, config })`, 'clip-4')"
        svg clip="no"
        id="clip-4"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const table = await gameStart({ rowCount: 5, columnCount: 7, config })</div>
        </div>
    </div>
</div>
<div title-sub>
    Validando combinações
</div>
<div section-description>
    Quando houver movimento realizado pelo jogador, devemos validar se é movimento válido ou não. Se for invalido, deve retornar o estado do tabuleiro para a situação anterior ao movimento invalido. <br/>
    Se for movimento válido, significa que houve combinação, então deverá ser feito o processo de analise da combinação. <br/><br/>
    Com o <span mark>fHelps</span> é possível retornar essas 3 propriedades: <br/>
    • <span mark>isMatch</span>: Informará se é válido ou inválido; <br/> 
    • <span mark>effects</span>: É um array, que se vier vazio, representa que não houve efeito de categoria; <br/>
    • <span mark>match</span>: Contém as informações de todos os matchs, tanto o simples (vertical e horizontal) quanto os cruzados. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const matchVerify = await isMatch({ table, config })`, 'clip-5')"
        svg clip="no"
        id="clip-5"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const matchVerify = await isMatch({ table, config })</div>
        </div>
    </div>
</div>
<div title-sub>
    Caso <span mark>não</span> haja efeito de categoria
</div>
<div section-description>
    Se o movimento for válido e não houver efeito de categoria, devemos seguir com a remoção das pedras combinadas do tabuleiro, deixando os espaços vazios. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const clearTable = await clearMatchs(table, matchVerify.match)`, 'clip-6')"
        svg clip="no"
        id="clip-6"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const clearTable = await clearMatchs(table, matchVerify.match)</div>
        </div>
    </div>
</div>
<div title-sub>
    Caso haja efeito de categoria
</div>
<div section-description>
    Quando o <span mark>matchVerify.effects</span> retornar um array preenchido, será necessário aplicar os efeitos de categorias ativados. Nesse momento, será necessário configurar 
    a lista de categorias que serão efetivamente utilizadas pelo tabuleiro, suas regras e métodos que executarão quando ativos. No stoneConfig declaramos as nomenclaturas 
    das categorias existentes. Nesse momento declararemos quais categorias realmente serão usadas e como serão usadas. <br/>
    Além disto, o método <span mark>category</span> possui três métodos: <br/>
    <span mark>categoryApplication</span>: Método utilizado para aplicar as categorias nas pedras do tabuleiro; <br/>
    <span mark>defaultfive</span>: Método que possui em propriedade outro método para aplicar os efeitos default da categoria de 5 pedras combinadas; <br/>
    <span mark>defaultfour</span>: Método que possui em propriedade outro método para aplicar os efeitos default da categoria de 4 pedras combinadas. <br/><br/>
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const { categoryApplication, defaultfive, defaultfour } = category\r\n\r\nconst activeCategorys = [\r\n  {\r\n   effect: defaultfour.patternFour,\r\n   category: 'pattern_four',\r\n   stoneIds: [1, 2, 3, 4, 5],\r\n   rule: 4\r\n  },{\r\n   effect: defaultfive.patternFive,\r\n   category: 'pattern_five',\r\n   stoneIds: [1, 2, 3, 4, 5],\r\n   rule: 5\r\n  }\r\n]`, 'clip-7')"
        svg clip="no"
        id="clip-7"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const { categoryApplication, defaultfive, defaultfour } = category</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope"></div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const activeCategorys = [</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;{</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;effect: defaultfour.patternFour,</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;category: 'pattern_four',</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;stoneIds: [1, 2, 3, 4, 5],</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;rule: 4</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;},{</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            &nbsp;&nbsp;&nbsp;&nbsp;effect: defaultfive.patternFive,
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            &nbsp;&nbsp;&nbsp;&nbsp;category: 'pattern_five',
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            &nbsp;&nbsp;&nbsp;&nbsp;stoneIds: [1, 2, 3, 4, 5],
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            &nbsp;&nbsp;&nbsp;&nbsp;rule: 5
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;}</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>]</div>
        </div>
    </div>
</div>
<div title-sub>
    Ativando efeitos de categoria
</div>
<div section-description>
    Após configurar as categorias que serão utilizadas, precisaremos verificar qual efeito foi ativado no match e executá-lo. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const explodeStones = await activeEffectsInMatchs({ table, activeCategorys, occurrences: effects })`, 'clip-8')"
        svg clip="no"
        id="clip-8"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const explodeStones = await activeEffectsInMatchs({ table, activeCategorys, occurrences: effects })</div>
        </div>
    </div>
</div>
<div title-sub>
    Sequência de efeito
</div>
<div section-description>
    Após executado o primeiro efeito, ele pode desencadear uma <span mark>onda de efeitos</span>, sendo ativados por serem atingidos pelo efeito anterior. Então, devemos verificar até onde essa "onda" vai e sua sequência.   
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const result = await sequenceHistory({ sequenceInitial: explodeStones, table, effects: activeCategorys })`, 'clip-9')"
        svg clip="no"
        id="clip-9"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const result = await sequenceHistory({ sequenceInitial: explodeStones, table, effects: activeCategorys })</div>
        </div>
    </div>
</div>

<div section-description>
    Após ativado os efeitos de categoria, devemos seguir com a remoção das pedras combinadas do tabuleiro <span mark>e as pedras afetadas pelos efeitos de categoria</span>, deixando os espaços vazios. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const clearTable = await clearTableMatchAndEffects({ table, match, explodeStones, result })`, 'clip-10')"
        svg clip="no"
        id="clip-10"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const clearTable = await clearTableMatchAndEffects({ table, match, explodeStones, result })</div>
        </div>
    </div>
</div>


<div section-description>
    <span mark>No fluxo STS, os dois caminhos (com ou sem efeito) é iniciado no mesmo ponto e se cruzam novamente após o método de limpeza</span>
</div>
<div title-sub>
    Aplicando a categoria nas pedras
</div>
<div section-description>
    Depois que a tabela foi limpa, devemos verificar se houve combinações elegíveis para receber efeitos de categoria e serem evoluídas para "pedras especiais". <br/><br/>
    E aqui recebemos mais uma definição nova, o <span mark>move</span>. Nela você deve informar qual foi a pedra que o jogador segurou e arrastou, assim como
    a pedra na qual ele "soltou" a pedra arrastada.<br/><br/>
    Obs.: O <span mark>move</span> também pode ser undefined, para situações onde o match não foi realizado por movimento direto do usuário. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const move = { drag: { row: 3, column: 2 }, drop: { row: 2, column: 2 } }\r\nconst applyCategory = await categoryApplication({ table: clearTable, activeCategorys, matchs: match, config, move })`, 'clip-11')"
        svg clip="no"
        id="clip-11"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const move = { drag: { row: 3, column: 2 }, drop: { row: 2, column: 2 } }</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const applyCategory = await categoryApplication({ table: clearTable, activeCategorys, matchs: match, config, move })</div>
        </div>
    </div>
</div>

<div section-description>
    Após aplicar o efeito de categoria, devemos reorganizar o tabuleiro. Ele foi limpo e possui espaços vazios de maneira aleatória. <br/>
    A lógica básica do match 3 puzzle é que ao elimininar a pedra de cima, a de baixo deve subir e deixar o seu espaço vazio e assim sucessivamente até que os espaços vazios fiquem sempre na última linha do tabuleiro.
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const reorganizeNewTable = await organizeStructure(applyCategory)`, 'clip-12')"
        svg clip="no"
        id="clip-12"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const reorganizeNewTable = await organizeStructure(applyCategory)</div>
        </div>
    </div>
</div>

<div section-description>
    Com o tabuleiro reorganizado, devemos preencher novamente os espaços vazios para dar continuidade no jogo. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const newTable = await insertNewStones(reorganizeNewTable, config)`, 'clip-13')"
        svg clip="no"
        id="clip-13"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const newTable = await insertNewStones(reorganizeNewTable, config)</div>
        </div>
    </div>
</div>

<div section-description>
    Com isso, temos o fluxo <span mark>STS</span> completo. 
</div>

<div title-sub attrac="ete">
    Método <span mark>End-To-End</span> (ETE)
</div>
<div section-description>
    O fluxo <span mark>ETE</span> é um método <span mark>fHelps</span>. Ele simula todo o fluxo básico do <span mark>STS</span> de uma vez só.
    Por isso que é o fluxo com o menor custo de desenvolvimento e mais custo de processamento, entretanto, ele retornará um objeto com o resultado separado de cada etapa do fluxo STS.
</div>
<div title-sub>
    Imports
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`import { fEventsProcess, stoneConfig, category, gameStart } from 'mpuzzlesye'`, 'clip-14')"
        svg clip="no"
        id="clip-14"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>import { fEventsProcess, stoneConfig, category, gameStart } from 'mpuzzlesye'</div>
        </div>
    </div>
</div>
<div section-description>
    O uso do <span mark>stoneConfig</span>, <span mark>category</span>, <span mark>gameStart</span> e <span mark>move</span> 
    seguem a mesma lógica, princípio e estrutura que foi explicado no fluxo <span mark>STS</span>. Então, aqui focarei em explicar somente sobre o método <span mark>fEventsProcess</span>.
</div>

<div section-description>
    <span mark>fEventsProcess</span><br/><br/>
    Método responsável por realizar o fluxo <span mark>ETE</span>, deve retornar um objeto completo com todas as informações que podem ser encontradas no fluxo <span mark>STS</span>.<br/>
    Em situação normal, o tempo de execução é menor que 0.02s, mas é mais propenso a ser afetado pela aplicação que o consumirá.  <br/><br/>
    Obs.: O <span mark>move</span> também pode ser undefined, para situações onde o match não foi realizado por movimento direto do usuário. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`const completFlow = await fEventsProcess({ table: valueTableAfterMove, config, activeCategorys, move })`, 'clip-15')"
        svg clip="no"
        id="clip-15"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>const completFlow = await fEventsProcess({ table: valueTableAfterMove, config, activeCategorys, move })</div>
        </div>
    </div>
</div>


<div title-sub>
    Considerações finais.
</div>

<div section-description>
  <span mark>COMBOS</span>:<br/><br/>
    Após realizar o fluxo completo, independente do fluxo escolhido (STS ou ETE), isso representa somente "1 jogada". <br/>
    Tem situações onde o <span mark>insertNewStones</span> preenchererá o tabuleiro e o novo tabuleiro já venha com combinações válidas feitas. <br/>
    Nesse cenário, pela regra básica do match 3 puzzle, isso contaria como <span mark>combo</span>. Daí, devemos novamente devolver o tabuleiro ao fluxo escolhido. 
    Só que desta vez, não houve movimento por parte do usuário e sim é uma continuação da primeira jogada, classificando a continuidade como <span mark>combo</span>. <br/>
    Para realizar esse procedimento, há diversas formas e realmente deixo em aberto para fazê-lo como achar melhor. <br/>
    Para exemplo, coloquei um demonstrativo abaixo, com certeza pode haver formas melhores de fazer isso. Mas, esse exemplo demonstra como pode ser feito. 
</div>
<div class="codeBoard">
    <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
    <div
        onclick="clipBoardEffect(`fEventsProcess({ table: valueTableAfterMove, config, activeCategorys, move })\r\n  .then(async (response) => {\r\n    if (response.newTable && response.isMatch.isMatch) {\r\n      let combo = [response]\r\n      let newStep = await fEventsProcess({ table: response.newTable, config, activeCategorys })\r\n      while (combo[combo.length - 1].isMatch.isMatch) {\r\n        newStep = await fEventsProcess({ table: newStep.newTable, config, activeCategorys })\r\n        combo = [...combo, newStep]\r\n    }\r\n  }\r\n})`, 'clip-16')"
        svg clip="no"
        id="clip-16"
        alt="copiar"
    ></div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>fEventsProcess({ table: valueTableAfterMove, config, activeCategorys, move })</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;.then(async (response) => {</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;if (response.newTable && response.isMatch.isMatch) {</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let combo = [response]</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let newStep = await fEventsProcess({ table: response.newTable, config, activeCategorys })</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (combo[combo.length - 1].isMatch.isMatch) {</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newStep = await fEventsProcess({ table: newStep.newTable, config, activeCategorys })</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;combo = [...combo, newStep]</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;&nbsp;&nbsp;}</div>
        </div>
    </div>
    <div flexr>
        <div class="simbol">$</div>
        <div class="codeScope">
            <div>&nbsp;&nbsp;})</div>
        </div>
    </div>
</div>
<div title-sub>
    <span mark>ATIVAÇÃO</span>:
</div>
<div section-description>
  As pedras especiais contém efeito de categoria. E esses efeitos podem ser ativados de 3 formas:<br/>
  • <span mark>Match</span>: Quando o usuário realiza uma combinação ou em sequência de combo, no match uma pedra de efeito é combinada com outras pedras do mesmo tipo, isso encadeia na ativação do efeito;<br/>
  • <span mark>Onda de efeito</span>: Quando a pedra especial é atingida por efeito de outra pedra especial, encadeando em sua ativação; <br/>
  • <span mark>Ativação individual</span>: Isso pode ser totalmente configurado, tanto pode deixar inativo sem que a pedra especial tenha esse recurso quanto tem como
  definir que caso o usuário click duas vezes em cima da pedra especial, ela será ativada (exemplo). Nesse caso, há um fluxo totalmente especifico para isso. 
</div>

<div title-sub>
  Imports
</div>
<div class="codeBoard">
  <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
  <div
      onclick="clipBoardEffect(`import { activeEffects } from 'mpuzzlesye'`, 'clip-17')"
      svg clip="no"
      id="clip-17"
      alt="copiar"
  ></div>
  <div flexr>
      <div class="simbol">$</div>
      <div class="codeScope">
          <div>import { activeEffects } from 'mpuzzlesye'</div>
      </div>
  </div>
</div>
<div title-sub>
    Definindo ação
</div>
<div section-description>
  Precisamos entregar qual foi a pedra clicada e sua posição, assim como as outras definições configuradas. 
</div>
<div class="codeBoard">
  <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
  <div
      onclick="clipBoardEffect(`const moveAction = { row: 3, column: 5, stone: { id: 2, type: 'light', category: 'pattern_four' } }\r\nconst effectReact = await activeEffects({ table, activeCategorys , ...moveAction })`, 'clip-18')"
      svg clip="no"
      id="clip-18"
      alt="copiar"
  ></div>
  <div flexr>
      <div class="simbol">$</div>
      <div class="codeScope">
          <div>const moveAction = { row: 3, column: 5, stone: { id: 2, type: 'light', category: 'pattern_four' } }</div>
      </div>
  </div>
  <div flexr>
      <div class="simbol">$</div>
      <div class="codeScope">
          <div>const effectReact = await activeEffects({ table, activeCategorys , ...moveAction })</div>
      </div>
  </div>
</div>

<div title-sub>
    Efeito de Onda
</div>
<div section-description>
  Após a ativação, as pedras que forem afetadas pelo efeito podem ser especiais também, desencadeando o efeito de onda. <br/>
  Daqui por diante, o fluxo é o mesmo utilizado no STS.
</div>
<div class="codeBoard">
  <div id="copySucess">Copiado com sucesso! <div id="closeNotification" onclick="clearNotification()">x</div></div>
  <div
      onclick="clipBoardEffect(`const sequence = await sequenceHistory({ sequenceInitial: effectReact, table, effects: activeCategorys })`, 'clip-19')"
      svg clip="no"
      id="clip-19"
      alt="copiar"
  ></div>
  <div flexr>
      <div class="simbol">$</div>
      <div class="codeScope">
          <div>const sequence = await sequenceHistory({ sequenceInitial: effectReact, table, effects: activeCategorys })</div>
      </div>
  </div>
</div>